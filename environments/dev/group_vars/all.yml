# main application vars
app_name: h
app_directory: /var/www/h
app_bin_directory: "{{ app_directory }}/bin"
app_log_directory: "{{ app_directory }}/logs"
app_error_log: "{{ app_log_directory }}/error.log"
app_access_log: "{{ app_log_directory }}/access.log"
app_worker_log: "{{ app_log_directory }}/celery.log"
app_celery_beat_log: "{{ app_log_directory }}/celery-beat.log"
app_server_name: hdev.openstax.org
app_user: hdev
app_user_group: www-data
app_user_home_directory: /var/www/h

virtualenv_name: "{{ app_name }}"
virtualenv_python: /usr/bin/python
virtualenv_base_directory: "{{ app_directory }}/.env"
virtualenv_bin_directory: "{{ virtualenv_base_directory }}/bin"
virtualenv_requirements_file: requirements-dev.in
virtualenv_requirements_path: "{{ app_directory }}/{{ virtualenv_requirements_file }}"

nginx_access_log: /var/log/nginx/access.log
nginx_error_log: /var/log/nginx/error.log
nginx_sites:
  - name: hypothesis

nginx:
  access_log: /var/log/nginx/access.log
  error_log: /var/log/nginx/error.log
  sites:
    - name: hypothesis

# With some of the more application specific things defined we are going to
# start creating the groups of different environmental variables we'll need
# to run our application. YAML anchors are used to reduce the need to duplicate
# these values. They are set once at the top of the file and then overwritten
# when necessary.

# rice.app.box.com values in order to do the annotation export
box_vars: &box_env
  BOX_CLIENT_ID: "{{ box.client_id }}"
  BOX_CLIENT_SECRET: "{{ box.client_secret }}"
  BOX_FOLDER_ID: "{{ box.folder_id }}"
  BOX_RSA_PRIVATE_KEY_PASS: "{{ box.rsa_private_key_pass }}"
  BOX_RSA_PRIVATE_KEY_PATH: "{{ box.rsa_private_key_path }}"
  BOX_JWT_KEY_ID: "{{ box.jwt_key_id }}"
  BOX_ENTERPRISE_ID: "{{ box.enterprise_id }}"

# Hypothesis env vars
hypothesis_vars: &hypothesis_env
  HYPOTHESIS_CLIENT_ID: "{{ wsgi.hypothesis_client_id }}"
  HYPOTHESIS_CLIENT_SECRET: "{{ wsgi.hypothesis_client_secret }}"
  HYPOTHESIS_SECRET_KEY: "{{ wsgi.hypothesis_secret_key }}"

# Celery env vars
celery_vars: &celery_env
  CELERY_BROKER_URL: "amqp://guest:guest@localhost/%2f"
  CELERY_RESULT_BACKEND: "amqp://"
  CELERYD_PID_FILE: "{{ app_directory }}/celery.pid"
  CELERYD_LOG_FILE: "{{ app_log_directory }}/celery.log"
  CELERYD_LOG_LEVEL: INFO
  CELERY_BEAT_LOG_FILE: "{{ app_log_directory }}/celery-beat.log"

# The default env used in each of the init_scripts for running Hypothesis
export_vars: &export_env
  <<: *box_env
  DATABASE_URL: "postgresql://{{ postgres.users[0].name }}:{{ postgres.users[0].password }}@{{ postgres.host }}/{{ postgres.users[0].db }}"

env_vars: &default_env
  <<: *box_env
  <<: *hypothesis_env
  APP_URL: "{{ app_server_name }}"
  SECRET_KEY: "{{ wsgi.hypothesis_secret_key }}"
  APP_RUN_OPTS: |
    "--name h \
      --paste /var/www/h/conf/app.ini \
      --capture-output \
      --error-logfile /var/www/h/logs/error.log \
      --access-logfile /var/www/h/logs/access.log \
      --bind unix:/tmp/h.sock"
  WEBSOCKET_RUN_OPTS: |
    "--name h-websocket \
      --paste /var/www/h/conf/websocket.ini \
      --error-logfile /var/www/h/logs/websocket-error.log \
      --access-logfile /var/www/h/logs/websocket-access.log \
      --bind unix:/tmp/h-websocket.sock"

# These scripts are placed in the application bin directory
# and utilized by systemd to start the app and workers
init_scripts:
  hypothesis:
    template: var/www/h/bin/init_script
    dest: /var/www/h/bin/hypothesis
    exec: exec python -m h "$@"
    state: present
    env_vars:
      <<: *default_env
  start_celery_worker:
    template: var/www/h/bin/init_script
    dest: /var/www/h/bin/start-celery-worker
    exec: "exec python -m h celery worker --logfile=${CELERYD_LOG_FILE} --loglevel=${CELERYD_LOG_LEVEL}"
    state: present
    env_vars:
      <<: *default_env
      <<: *celery_env
  start_celery_beat:
    template: var/www/h/bin/init_script
    dest: /var/www/h/bin/start-celery-beat
    exec: "exec python -m h celery beat --logfile=${CELERY_BEAT_LOG_FILE} --loglevel=${CELERYD_LOG_LEVEL}"
    state: present
    env_vars:
      <<: *default_env
      <<: *celery_env
  annotation_export:
    template: var/www/h/bin/init_script
    dest: /var/www/h/bin/export-annotations
    exec: "boxex {{ app_directory }}/sql/annotation_export.sql {{ app_server_name }}-$(date '+%Y-%m-%d:%H:%M').csv"
    state: present
    env_vars:
      <<: *export_env

# These are the systemd unitfiles needed to start the main application
services:
  h_service:
    application_name: "{{ app_name }}"
    template: lib/systemd/system/application.service
    description: "{{ app_name }} gunicorn service"
    dest: "/lib/systemd/system/{{ app_name}}.service"
    requires: h.socket
    state: present
    params:
      EnvironmentFile: "-/etc/default/{{ app_name }}"
      PIDFile: "/run/gunicorn/{{ app_name }}-pid"
      User: "{{ app_user_name }}"
      Group: "{{ app_user_group }}"
      RuntimeDirectory: gunicorn
      WorkingDirectory: "{{ app_directory }}"
      ExecStart: "{{ virtualenv_base_bin_directory }}/gunicorn $APP_RUN_OPTS"
      ExecReload: "/bin/kill -s HUP $MAINPID"
      ExecStop: "/bin/kill -s TERM $MAINPID"
      PrivateTmp: true
  h_socket:
    application_name: "{{ app_name }}.socket"
    template: lib/systemd/system/application.socket
    description: "{{ app_name }} gunicorn socket"
    dest: "/lib/systemd/system/{{ app_name}}.socket"
    state: present
    params:
      ListenStream: "/tmp/{{ app_name }}.sock"
  h_worker:
    application_name: "{{ app_name }}-worker"
    template: lib/systemd/system/application.service
    description: "{{ app_name }} gunicorn service"
    dest: "/lib/systemd/system/{{ app_name}}-worker.service"
    state: present
    params:
      PIDFile: "{{ app_directory }}/celery.pid"
      User: "{{ app_user_name }}"
      Group: "{{ app_user_group }}"
      RuntimeDirectory: celery
      WorkingDirectory: "{{ app_directory }}"
      ExecStart: "{{ app_bin_directory }}/start-celery-worker"
      ExecReload: "/bin/kill -s HUP $MAINPID"
      ExecStop: "/bin/kill -s TERM $MAINPID"
  h_beat:
    application_name: "{{ app_name }}-beat"
    template: lib/systemd/system/application.service
    description: "{{ app_name }} gunicorn service"
    dest: "/lib/systemd/system/{{ app_name}}-beat.service"
    state: present
    params:
      PIDFile: "{{ app_directory }}/celeryscheduler.pid"
      User: "{{ app_user_name }}"
      Group: "{{ app_user_group }}"
      RuntimeDirectory: celery
      WorkingDirectory: "{{ app_directory }}"
      ExecStart: "{{ app_bin_directory }}/start-celery-beat"
      ExecReload: "/bin/kill -s HUP $MAINPID"
      ExecStop: "/bin/kill -s TERM $MAINPID"
      PrivateTmp: true

# These are the environment files created for the services
env_files:
  hypothesis:
    template: etc/default/env
    dest: /etc/default/h
    env_vars:
      <<: *default_env

# These are the tmpfiles.d used for the services which set permissions on the tmp files
tmpfiles:
 h_socket:
   template: etc/tmpfiles.d/tmpfile
   dest: "/etc/tmpfiles.d/{{ app_name }}.conf"
   tmpfile: "d /tmp/{{ app_name }}.sock 0755 {{ app_user_name }} {{ app_user_group }} -"

# The vars originally used in this playbook were based on using hashes
# We are moving away from that so to using "flatter"
# namespaced variables that start with rolename_var_name.

# postgresql
pg_version: 9.6
pg_is_master_server: true
pg_host: "{{ postgres.host }}"

pg_databases:
  - name: "{{ postgres.databases[0].name }}"

pg_users:
  - name: "{{ postgres.users[0].name }}"
    password:  "{{ postgres.users[0].password }}"
    db: "{{ postgres.users[0].db }}"

# npm
nodejs_npm_global_packages: ['gulp-cli']
nodejs_install_npm_user: "{{ app_user_name }}"
nodejs_package_json_path: "{{ app_directory }}"

# ssl
ssl_www_user: www-data
ssl_s3_bucket: openstax-config
ssl_s3_primary_cert: ssl/openstax.org/openstax.org.crt
ssl_s3_intermediate_cert: ssl/openstax.org/gd_bundle-g2-g1.crt
ssl_s3_private_key:  ssl/openstax.org/openstax.org.key
ssl_s3_key_name: openstax.pem
ssl_s3_aws_secret_access_key: "{{ aws.secret_access_key }}"
ssl_s3_aws_access_key_id: "{{ aws.access_key_id }}"
ssl_cert_file_name: openstax.crt
ssl_copy: ~

# papertrail
papertrail_url: "{{ papertrail.url }}"
papertrail_ssl_dest_cert_dir: "{{ ssl_dest_cert_dir }}"
papertrail_watch_files:
  - path: "{{ app_access_log }}"
    unique_name: "{{ app_name }}_access"
  - path: "{{ app_error_log }}"
    unique_name: "{{ app_name }}_error"
  - path: "{{ app_worker_log }}"
    unique_name: "{{ app_name }}_celery_worker"
  - path: "{{ app_celery_beat_log }}"
    unique_name: "{{ app_name }}_celery_beat"
  - path: "{{ nginx_error_log }}"
    unique_name: "{{ app_name }}_nginx_error"
  - path: "{{ nginx_access_log }}"
    unique_name: "{{ app_name }}_nginx_access"

# We define the main settings for the application role. This should happen last so that
# we can assume all the other values exist if needed and can be passed into our config
hypothesis:
  application_name: "{{ app_name }}"
  user: "{{ app_user_name }}"
  group: "{{ app_user_group }}"
  server_name: "{{ app_server_name }}"
  application_dir: "{{ app_directory }}"
  ssl_on: yes
  ssl_cert_file_name: "{{ ssl_cert_file_name }}"
  s3_key_name: "{{ ssl_s3_key_name }}"
  virtualenv_bin_dir: "{{ virtualenv_base_bin_directory }}"
  virtualenv_python: "{{ virtualenv_python }}"
  client_id: "{{ wsgi.hypothesis_client_id }}"
  client_secret: "{{ wsgi.hypothesis_client_secret }}"
  secret_key: "{{ wsgi.hypothesis_secret_key }}"
  box_rsa_private_key_content: "{{ box.rsa_private_key_content }}"
  box_rsa_private_key_path: "{{ box.rsa_private_key_path }}"
  database:
    user: "{{ pg_users[0].name }}"
    password: "{{ pg_users[0].password }}"
    host: "{{ pg_host }}"
    database_name: "{{ pg_databases[0].name }}"
  init_scripts: "{{ init_scripts }}"
  services: "{{ services }}"
  env_files: "{{ env_files }}"
  tmpfiles: "{{ tmpfiles }}"

# Override the vars specific to the role
openstax_wsgi_role: "{{ wsgi }}"
openstax_hypothesis_role: "{{ hypothesis }}"
